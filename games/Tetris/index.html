<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TETRIS Challenge Mode</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --dark: #1e293b;
            --darker: #0f172a;
            --light: #f8fafc;
            --gray: #64748b;
            --glass: rgba(30, 41, 59, 0.7);
            --border: rgba(255, 255, 255, 0.1);
        }

        body {
            background: linear-gradient(135deg, #0f172a, #1e293b);
            color: var(--light);
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.5;
            min-height: 100vh;
            overflow-x: hidden;
            padding: 20px;
        }

        /* Container with proper scrolling */
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Header styling */
        .header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 25px;
        }

        .title {
            font-size: 3.5rem;
            font-weight: 800;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #6366f1, #8b5cf6, #ec4899);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 10px rgba(99, 102, 241, 0.2);
        }

        .subtitle {
            font-size: 1.2rem;
            color: #94a3b8;
            max-width: 600px;
            margin: 0 auto;
            font-weight: 300;
        }

        /* Main game layout */
        .game-layout {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 25px;
            margin-bottom: 25px;
        }

        /* Stats panel */
        .stats-panel {
            background: var(--glass);
            backdrop-filter: blur(12px);
            border-radius: 16px;
            padding: 25px;
            border: 1px solid var(--border);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
        }

        .panel-title {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 20px;
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .score-display {
            font-size: 3.2rem;
            font-weight: 800;
            text-align: center;
            margin: 15px 0;
            background: linear-gradient(45deg, #6366f1, #8b5cf6);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: white;
            margin: 8px 0;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Game board container */
        .game-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .board-wrapper {
            background: rgba(15, 23, 42, 0.6);
            border-radius: 16px;
            padding: 20px;
            border: 2px solid rgba(99, 102, 241, 0.3);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .board-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .level-progress {
            flex: 1;
            max-width: 200px;
        }

        .progress-label {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-bottom: 8px;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #6366f1, #8b5cf6);
            border-radius: 4px;
            width: 10%;
            transition: width 0.5s ease;
        }

        /* Game board styling */
        .game-board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(20, 1fr);
            gap: 2px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            aspect-ratio: 1/2;
            margin: 0 auto;
            max-width: 100%;
            width: min(400px, 90vw);
        }

        .cell {
            border-radius: 4px;
            background: rgba(30, 41, 59, 0.4);
            transition: all 0.2s ease;
            position: relative;
        }

        .cell::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .cell.active::after {
            opacity: 1;
        }

        /* Tetromino colors */
        .I { background: linear-gradient(135deg, #06b6d4, #0891b2); }
        .O { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .T { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        .S { background: linear-gradient(135deg, #10b981, #059669); }
        .Z { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .J { background: linear-gradient(135deg, #3b82f6, #2563eb); }
        .L { background: linear-gradient(135deg, #f97316, #ea580c); }

        /* Preview panels */
        .preview-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .preview-panel {
            flex: 1;
            text-align: center;
        }

        .preview-title {
            font-size: 1.1rem;
            color: #94a3b8;
            margin-bottom: 15px;
        }

        .preview-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 2px;
            width: 120px;
            height: 120px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 10px;
            padding: 8px;
            margin: 0 auto;
        }

        .preview-cell {
            border-radius: 3px;
            background: rgba(30, 41, 59, 0.3);
        }

        /* Controls section */
        .controls-section {
            background: var(--glass);
            backdrop-filter: blur(12px);
            border-radius: 16px;
            padding: 25px;
            border: 1px solid var(--border);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .key {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(99, 102, 241, 0.15);
            border: 2px solid rgba(99, 102, 241, 0.3);
            border-radius: 12px;
            font-weight: 700;
            font-size: 1.2rem;
        }

        .key-label {
            font-size: 0.9rem;
            color: #94a3b8;
            text-align: center;
        }

        /* Game buttons */
        .game-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(45deg, var(--primary-dark), #7c3aed);
        }

        .btn-warning {
            background: linear-gradient(45deg, #f59e0b, #d97706);
            color: white;
        }

        .btn-warning:hover {
            background: linear-gradient(45deg, #d97706, #b45309);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(45deg, #dc2626, #b91c1c);
        }

        /* Game over modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s ease;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: linear-gradient(135deg, var(--darker), var(--dark));
            border-radius: 20px;
            padding: 40px;
            width: 90%;
            max-width: 500px;
            text-align: center;
            transform: scale(0.8);
            transition: transform 0.4s ease;
            border: 1px solid rgba(99, 102, 241, 0.3);
        }

        .modal.active .modal-content {
            transform: scale(1);
        }

        .modal-title {
            font-size: 2.8rem;
            font-weight: 800;
            margin-bottom: 30px;
            color: #ef4444;
        }

        .final-score {
            font-size: 3.5rem;
            font-weight: 800;
            margin: 20px 0;
            background: linear-gradient(45deg, #6366f1, #8b5cf6, #ec4899);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .modal-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 25px 0;
        }

        .stat {
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: white;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .game-layout {
                grid-template-columns: 250px 1fr 250px;
            }
        }

        @media (max-width: 992px) {
            .game-layout {
                grid-template-columns: 1fr;
            }
            
            .preview-container {
                flex-direction: column;
                align-items: center;
            }
            
            .stats-panel, .controls-section {
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            .title {
                font-size: 2.8rem;
            }
            
            .game-board {
                width: min(320px, 90vw);
            }
            
            .controls-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .game-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 100%;
                max-width: 300px;
                justify-content: center;
            }
        }

        @media (max-width: 480px) {
            .title {
                font-size: 2.2rem;
            }
            
            .subtitle {
                font-size: 1rem;
            }
            
            .game-board {
                width: min(280px, 90vw);
            }
            
            .preview-grid {
                width: 100px;
                height: 100px;
            }
            
            .key {
                width: 50px;
                height: 50px;
                font-size: 1rem;
            }
        }

        /* Animations */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(99, 102, 241, 0); }
            100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0); }
        }

        .pulse {
            animation: pulse 1.5s infinite;
        }

        @keyframes lineClear {
            0% { background-color: rgba(255, 255, 255, 0.8); transform: scale(1); }
            50% { background-color: rgba(255, 255, 255, 0.9); transform: scale(1.05); }
            100% { background-color: transparent; transform: scale(1); }
        }

        .line-clear {
            animation: lineClear 0.4s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1 class="title">TETRIS CHALLENGE</h1>
            <p class="subtitle">Classic block-stacking puzzle with modern gameplay and responsive design</p>
        </header>

        <div class="game-layout">
            <!-- Left Stats Panel -->
            <div class="stats-panel">
                <h2 class="panel-title"><i class="fas fa-trophy"></i> SCORE</h2>
                <div class="score-display" id="score">0</div>
                
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="lines">0</div>
                        <div class="stat-label">LINES</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="level">1</div>
                        <div class="stat-label">LEVEL</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="speed">1.0x</div>
                        <div class="stat-label">SPEED</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="high-score">0</div>
                        <div class="stat-label">HIGH SCORE</div>
                    </div>
                </div>

                <div class="level-progress">
                    <div class="progress-label">LEVEL PROGRESS</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="level-fill"></div>
                    </div>
                </div>
            </div>

            <!-- Main Game Area -->
            <div class="game-container">
                <div class="board-wrapper">
                    <div class="board-header">
                        <h2 style="font-size: 1.4rem; font-weight: 700;">GAME BOARD</h2>
                        <div class="level-display">
                            <span style="background: rgba(99, 102, 241, 0.2); padding: 6px 12px; border-radius: 8px; font-weight: 600;">
                                LEVEL <span id="level-display">1</span>
                            </span>
                        </div>
                    </div>
                    <div class="game-board" id="game-board"></div>
                    
                    <div class="preview-container">
                        <div class="preview-panel">
                            <div class="preview-title">NEXT PIECE</div>
                            <div class="preview-grid" id="next-piece"></div>
                        </div>
                        <div class="preview-panel">
                            <div class="preview-title">HOLD</div>
                            <div class="preview-grid" id="hold-piece"></div>
                        </div>
                    </div>
                </div>
                
                <div class="game-buttons">
                    <button id="start-btn" class="btn btn-primary">
                        <i class="fas fa-play"></i> START GAME
                    </button>
                    <button id="pause-btn" class="btn btn-warning">
                        <i class="fas fa-pause"></i> PAUSE
                    </button>
                    <button id="reset-btn" class="btn btn-danger">
                        <i class="fas fa-redo"></i> RESET
                    </button>
                </div>
            </div>

            <!-- Right Controls Panel -->
            <div class="controls-section">
                <h2 class="panel-title"><i class="fas fa-keyboard"></i> CONTROLS</h2>
                
                <div class="controls-grid">
                    <div class="control-item">
                        <div class="key">←</div>
                        <div class="key-label">MOVE LEFT</div>
                    </div>
                    <div class="control-item">
                        <div class="key">→</div>
                        <div class="key-label">MOVE RIGHT</div>
                    </div>
                    <div class="control-item">
                        <div class="key">↓</div>
                        <div class="key-label">SOFT DROP</div>
                    </div>
                    <div class="control-item">
                        <div class="key">↑</div>
                        <div class="key-label">ROTATE</div>
                    </div>
                    <div class="control-item">
                        <div class="key">SPACE</div>
                        <div class="key-label">HARD DROP</div>
                    </div>
                    <div class="control-item">
                        <div class="key">C</div>
                        <div class="key-label">HOLD</div>
                    </div>
                </div>
                
                <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid var(--border);">
                    <h3 style="font-size: 1.1rem; margin-bottom: 15px; color: white;">GAME FEATURES</h3>
                    <ul style="list-style: none; display: grid; gap: 8px;">
                        <li style="display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-check-circle" style="color: #10b981;"></i>
                            <span>Smooth responsive controls</span>
                        </li>
                        <li style="display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-check-circle" style="color: #10b981;"></i>
                            <span>Ghost piece preview</span>
                        </li>
                        <li style="display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-check-circle" style="color: #10b981;"></i>
                            <span>Combo scoring system</span>
                        </li>
                        <li style="display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-check-circle" style="color: #10b981;"></i>
                            <span>Hold piece functionality</span>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal" id="game-over-modal">
        <div class="modal-content">
            <h2 class="modal-title"><i class="fas fa-skull-crossbones"></i> GAME OVER</h2>
            <p>Your final score</p>
            <div class="final-score" id="final-score">0</div>
            
            <div class="modal-stats">
                <div class="stat">
                    <div class="stat-label">LEVEL</div>
                    <div class="stat-value" id="final-level">1</div>
                </div>
                <div class="stat">
                    <div class="stat-label">LINES</div>
                    <div class="stat-value" id="final-lines">0</div>
                </div>
            </div>
            
            <div class="modal-buttons">
                <button id="restart-btn" class="btn btn-primary">
                    <i class="fas fa-redo"></i> PLAY AGAIN
                </button>
            </div>
        </div>
    </div>

    <script>
        // Tetris Game Implementation
        class TetrisGame {
            constructor() {
                // DOM elements
                this.boardElement = document.getElementById('game-board');
                this.nextPieceElement = document.getElementById('next-piece');
                this.holdPieceElement = document.getElementById('hold-piece');
                this.scoreElement = document.getElementById('score');
                this.highScoreElement = document.getElementById('high-score');
                this.linesElement = document.getElementById('lines');
                this.levelElement = document.getElementById('level');
                this.levelDisplayElement = document.getElementById('level-display');
                this.speedElement = document.getElementById('speed');
                this.levelFillElement = document.getElementById('level-fill');
                this.finalScoreElement = document.getElementById('final-score');
                this.finalLevelElement = document.getElementById('final-level');
                this.finalLinesElement = document.getElementById('final-lines');
                
                // Buttons
                this.startBtn = document.getElementById('start-btn');
                this.pauseBtn = document.getElementById('pause-btn');
                this.resetBtn = document.getElementById('reset-btn');
                this.restartBtn = document.getElementById('restart-btn');
                this.gameOverModal = document.getElementById('game-over-modal');
                
                // Game state
                this.board = Array(20).fill().map(() => Array(10).fill(0));
                this.currentPiece = null;
                this.nextPiece = null;
                this.holdPiece = null;
                this.holdUsed = false;
                this.score = 0;
                this.highScore = localStorage.getItem('tetrisHighScore') || 0;
                this.lines = 0;
                this.level = 1;
                this.isPaused = false;
                this.isGameOver = false;
                this.gameInterval = null;
                this.dropSpeed = 1000;
                
                // Tetromino definitions
                this.tetrominoes = {
                    I: {
                        shape: [
                            [0, 0, 0, 0],
                            [1, 1, 1, 1],
                            [0, 0, 0, 0],
                            [0, 0, 0, 0]
                        ],
                        color: 'I'
                    },
                    O: {
                        shape: [
                            [1, 1],
                            [1, 1]
                        ],
                        color: 'O'
                    },
                    T: {
                        shape: [
                            [0, 1, 0],
                            [1, 1, 1],
                            [0, 0, 0]
                        ],
                        color: 'T'
                    },
                    S: {
                        shape: [
                            [0, 1, 1],
                            [1, 1, 0],
                            [0, 0, 0]
                        ],
                        color: 'S'
                    },
                    Z: {
                        shape: [
                            [1, 1, 0],
                            [0, 1, 1],
                            [0, 0, 0]
                        ],
                        color: 'Z'
                    },
                    J: {
                        shape: [
                            [1, 0, 0],
                            [1, 1, 1],
                            [0, 0, 0]
                        ],
                        color: 'J'
                    },
                    L: {
                        shape: [
                            [0, 0, 1],
                            [1, 1, 1],
                            [0, 0, 0]
                        ],
                        color: 'L'
                    }
                };
                
                // Initialize the game
                this.init();
            }
            
            init() {
                // Set high score display
                this.highScoreElement.textContent = this.highScore;
                
                // Create game board
                this.createBoard();
                
                // Create preview displays
                this.createPreviewDisplays();
                
                // Event listeners
                this.startBtn.addEventListener('click', () => this.startGame());
                this.pauseBtn.addEventListener('click', () => this.togglePause());
                this.resetBtn.addEventListener('click', () => this.resetGame());
                this.restartBtn.addEventListener('click', () => this.restartGame());
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));
                
                // Initial state
                this.updateDisplay();
            }
            
            createBoard() {
                this.boardElement.innerHTML = '';
                for (let row = 0; row < 20; row++) {
                    for (let col = 0; col < 10; col++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        this.boardElement.appendChild(cell);
                    }
                }
            }
            
            createPreviewDisplays() {
                // Next piece display
                this.nextPieceElement.innerHTML = '';
                for (let i = 0; i < 16; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('preview-cell');
                    this.nextPieceElement.appendChild(cell);
                }
                
                // Hold piece display
                this.holdPieceElement.innerHTML = '';
                for (let i = 0; i < 16; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('preview-cell');
                    this.holdPieceElement.appendChild(cell);
                }
            }
            
            getRandomPiece() {
                const pieces = Object.keys(this.tetrominoes);
                const randomPiece = pieces[Math.floor(Math.random() * pieces.length)];
                return {
                    shape: this.tetrominoes[randomPiece].shape,
                    color: this.tetrominoes[randomPiece].color,
                    type: randomPiece,
                    row: 0,
                    col: Math.floor((10 - this.tetrominoes[randomPiece].shape[0].length) / 2)
                };
            }
            
            drawBoard() {
                // Clear the board
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.className = 'cell';
                    const index = Array.from(this.boardElement.children).indexOf(cell);
                    const row = Math.floor(index / 10);
                    const col = index % 10;
                    if (this.board[row][col]) {
                        cell.classList.add(this.board[row][col]);
                        cell.classList.add('active');
                    }
                });
                
                // Draw current piece
                if (this.currentPiece && !this.isPaused && !this.isGameOver) {
                    // Draw ghost piece (preview of where piece will land)
                    this.drawGhostPiece();
                    
                    // Draw active piece
                    for (let row = 0; row < this.currentPiece.shape.length; row++) {
                        for (let col = 0; col < this.currentPiece.shape[row].length; col++) {
                            if (this.currentPiece.shape[row][col]) {
                                const boardRow = this.currentPiece.row + row;
                                const boardCol = this.currentPiece.col + col;
                                if (boardRow >= 0 && boardRow < 20 && boardCol >= 0 && boardCol < 10) {
                                    const index = boardRow * 10 + boardCol;
                                    const cell = this.boardElement.children[index];
                                    if (cell) {
                                        cell.classList.add(this.currentPiece.color);
                                        cell.classList.add('active');
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            drawGhostPiece() {
                if (!this.currentPiece) return;
                
                // Find where the piece would land
                let ghostRow = this.currentPiece.row;
                while (!this.checkCollision(this.currentPiece, ghostRow + 1, this.currentPiece.col)) {
                    ghostRow++;
                }
                
                // Draw ghost piece
                for (let row = 0; row < this.currentPiece.shape.length; row++) {
                    for (let col = 0; col < this.currentPiece.shape[row].length; col++) {
                        if (this.currentPiece.shape[row][col]) {
                            const boardRow = ghostRow + row;
                            const boardCol = this.currentPiece.col + col;
                            if (boardRow >= 0 && boardRow < 20 && boardCol >= 0 && boardCol < 10) {
                                const index = boardRow * 10 + boardCol;
                                const cell = this.boardElement.children[index];
                                if (cell && !cell.classList.contains('active')) {
                                    cell.style.opacity = '0.3';
                                }
                            }
                        }
                    }
                }
            }
            
            drawNextPiece() {
                this.nextPieceElement.querySelectorAll('.preview-cell').forEach(cell => {
                    cell.className = 'preview-cell';
                });
                
                if (this.nextPiece) {
                    const offsetX = (4 - this.nextPiece.shape[0].length) / 2;
                    const offsetY = (4 - this.nextPiece.shape.length) / 2;
                    
                    for (let row = 0; row < this.nextPiece.shape.length; row++) {
                        for (let col = 0; col < this.nextPiece.shape[row].length; col++) {
                            if (this.nextPiece.shape[row][col]) {
                                const displayRow = Math.floor(offsetY) + row;
                                const displayCol = Math.floor(offsetX) + col;
                                const index = displayRow * 4 + displayCol;
                                const cell = this.nextPieceElement.children[index];
                                if (cell) {
                                    cell.classList.add(this.nextPiece.color);
                                }
                            }
                        }
                    }
                }
            }
            
            drawHoldPiece() {
                this.holdPieceElement.querySelectorAll('.preview-cell').forEach(cell => {
                    cell.className = 'preview-cell';
                });
                
                if (this.holdPiece) {
                    const offsetX = (4 - this.holdPiece.shape[0].length) / 2;
                    const offsetY = (4 - this.holdPiece.shape.length) / 2;
                    
                    for (let row = 0; row < this.holdPiece.shape.length; row++) {
                        for (let col = 0; col < this.holdPiece.shape[row].length; col++) {
                            if (this.holdPiece.shape[row][col]) {
                                const displayRow = Math.floor(offsetY) + row;
                                const displayCol = Math.floor(offsetX) + col;
                                const index = displayRow * 4 + displayCol;
                                const cell = this.holdPieceElement.children[index];
                                if (cell) {
                                    cell.classList.add(this.holdPiece.color);
                                }
                            }
                        }
                    }
                }
            }
            
            checkCollision(piece, rowOffset = 0, colOffset = 0) {
                if (!piece) return false;
                
                for (let row = 0; row < piece.shape.length; row++) {
                    for (let col = 0; col < piece.shape[row].length; col++) {
                        if (piece.shape[row][col]) {
                            const newRow = piece.row + row + rowOffset;
                            const newCol = piece.col + col + colOffset;
                            
                            // Check boundaries
                            if (newCol < 0 || newCol >= 10 || newRow >= 20) {
                                return true;
                            }
                            
                            // Check collision with placed pieces (only for rows >= 0)
                            if (newRow >= 0 && this.board[newRow][newCol]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            rotatePiece() {
                if (!this.currentPiece || this.isPaused || this.isGameOver || this.currentPiece.type === 'O') {
                    return false;
                }
                
                const originalShape = this.currentPiece.shape;
                const rows = originalShape.length;
                const cols = originalShape[0].length;
                
                // Create new rotated shape (90 degrees clockwise)
                const rotated = Array(cols).fill().map(() => Array(rows).fill(0));
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        rotated[col][rows - 1 - row] = originalShape[row][col];
                    }
                }
                
                const originalShapeRef = this.currentPiece.shape;
                this.currentPiece.shape = rotated;
                
                // Wall kick - try different positions if rotation causes collision
                const kicks = [
                    { row: 0, col: 0 },      // Original position
                    { row: 0, col: -1 },     // Left
                    { row: 0, col: 1 },      // Right
                    { row: -1, col: 0 },     // Up
                    { row: 1, col: 0 },      // Down
                ];
                
                let validPosition = false;
                for (const kick of kicks) {
                    if (!this.checkCollision(this.currentPiece, kick.row, kick.col)) {
                        this.currentPiece.row += kick.row;
                        this.currentPiece.col += kick.col;
                        validPosition = true;
                        break;
                    }
                }
                
                if (!validPosition) {
                    // Restore original shape if no valid position found
                    this.currentPiece.shape = originalShapeRef;
                    return false;
                }
                
                this.drawBoard();
                return true;
            }
            
            movePiece(rowOffset, colOffset) {
                if (!this.currentPiece || this.isPaused || this.isGameOver) return false;
                
                if (!this.checkCollision(this.currentPiece, rowOffset, colOffset)) {
                    this.currentPiece.row += rowOffset;
                    this.currentPiece.col += colOffset;
                    this.drawBoard();
                    return true;
                }
                return false;
            }
            
            hardDrop() {
                if (!this.currentPiece || this.isPaused || this.isGameOver) return;
                
                let dropped = 0;
                while (this.movePiece(1, 0)) {
                    dropped++;
                    this.score += 1; // Bonus points for hard drop
                }
                
                if (dropped > 0) {
                    this.updateDisplay();
                }
                
                this.placePiece();
            }
            
            holdCurrentPiece() {
                if (this.isPaused || this.isGameOver || this.holdUsed) return;
                
                if (!this.holdPiece) {
                    // First hold - take current piece and get new one
                    this.holdPiece = {
                        shape: this.tetrominoes[this.currentPiece.type].shape,
                        color: this.currentPiece.color,
                        type: this.currentPiece.type
                    };
                    this.currentPiece = this.nextPiece;
                    this.nextPiece = this.getRandomPiece();
                    this.drawNextPiece();
                    this.drawHoldPiece();
                } else {
                    // Swap current piece with hold piece
                    const temp = {
                        shape: this.tetrominoes[this.currentPiece.type].shape,
                        color: this.currentPiece.color,
                        type: this.currentPiece.type
                    };
                    
                    this.currentPiece = {
                        shape: this.tetrominoes[this.holdPiece.type].shape,
                        color: this.holdPiece.color,
                        type: this.holdPiece.type,
                        row: 0,
                        col: Math.floor((10 - this.tetrominoes[this.holdPiece.type].shape[0].length) / 2)
                    };
                    
                    this.holdPiece = temp;
                    this.drawHoldPiece();
                }
                
                this.holdUsed = true;
                this.drawBoard();
            }
            
            placePiece() {
                if (!this.currentPiece) return;
                
                // Add piece to board
                for (let row = 0; row < this.currentPiece.shape.length; row++) {
                    for (let col = 0; col < this.currentPiece.shape[row].length; col++) {
                        if (this.currentPiece.shape[row][col]) {
                            const boardRow = this.currentPiece.row + row;
                            const boardCol = this.currentPiece.col + col;
                            if (boardRow >= 0 && boardRow < 20) {
                                this.board[boardRow][boardCol] = this.currentPiece.color;
                            }
                        }
                    }
                }
                
                this.holdUsed = false;
                
                // Check for completed lines
                this.clearLines();
                
                // Get next piece
                this.currentPiece = this.nextPiece;
                this.nextPiece = this.getRandomPiece();
                this.drawNextPiece();
                
                // Check if game over
                if (this.checkCollision(this.currentPiece)) {
                    this.gameOver();
                    return;
                }
                
                this.drawBoard();
            }
            
            clearLines() {
                let linesCleared = 0;
                let linesToClear = [];
                
                // Find completed lines
                for (let row = 19; row >= 0; row--) {
                    if (this.board[row].every(cell => cell !== 0)) {
                        linesToClear.push(row);
                        linesCleared++;
                    }
                }
                
                if (linesCleared > 0) {
                    // Animate line clear
                    linesToClear.forEach(row => {
                        for (let col = 0; col < 10; col++) {
                            const index = row * 10 + col;
                            const cell = this.boardElement.children[index];
                            if (cell) {
                                cell.classList.add('line-clear');
                            }
                        }
                    });
                    
                    // Update score based on lines cleared and level
                    const linePoints = [0, 100, 300, 500, 800]; // 0, 1, 2, 3, 4 lines
                    const baseScore = linePoints[linesCleared];
                    const levelBonus = baseScore * (this.level - 1);
                    
                    this.score += baseScore + levelBonus;
                    
                    // Remove lines and add new empty lines at top
                    linesToClear.sort((a, b) => b - a); // Sort descending
                    linesToClear.forEach(row => {
                        this.board.splice(row, 1);
                        this.board.unshift(Array(10).fill(0));
                    });
                    
                    this.lines += linesCleared;
                    this.linesElement.textContent = this.lines;
                    
                    // Update level
                    const newLevel = Math.floor(this.lines / 10) + 1;
                    if (newLevel > this.level) {
                        this.level = newLevel;
                        this.levelElement.textContent = this.level;
                        this.levelDisplayElement.textContent = this.level;
                        
                        // Increase speed
                        this.dropSpeed = Math.max(100, 1000 - (this.level - 1) * 100);
                        this.speedElement.textContent = `${(1000 / this.dropSpeed).toFixed(1)}x`;
                    }
                    
                    // Update level progress
                    const levelProgress = (this.lines % 10) / 10 * 100;
                    this.levelFillElement.style.width = `${Math.min(100, levelProgress)}%`;
                    
                    // Update display
                    this.updateDisplay();
                    
                    // Visual feedback
                    this.scoreElement.classList.add('pulse');
                    setTimeout(() => this.scoreElement.classList.remove('pulse'), 1000);
                }
            }
            
            updateDisplay() {
                this.scoreElement.textContent = this.score;
                this.linesElement.textContent = this.lines;
                this.levelElement.textContent = this.level;
                this.levelDisplayElement.textContent = this.level;
                this.speedElement.textContent = `${(1000 / this.dropSpeed).toFixed(1)}x`;
                
                // Update high score
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    this.highScoreElement.textContent = this.highScore;
                    localStorage.setItem('tetrisHighScore', this.highScore);
                }
            }
            
            startGame() {
                if (this.isGameOver) {
                    this.resetGame();
                }
                
                if (!this.currentPiece) {
                    this.currentPiece = this.getRandomPiece();
                    this.nextPiece = this.getRandomPiece();
                    this.drawNextPiece();
                }
                
                this.isPaused = false;
                this.isGameOver = false;
                
                // Start game loop
                if (this.gameInterval) {
                    clearInterval(this.gameInterval);
                }
                
                this.gameInterval = setInterval(() => {
                    if (!this.isPaused && !this.isGameOver) {
                        if (!this.movePiece(1, 0)) {
                            this.placePiece();
                        }
                    }
                }, this.dropSpeed);
                
                this.drawBoard();
                this.pauseBtn.innerHTML = '<i class="fas fa-pause"></i> PAUSE';
                this.pauseBtn.className = 'btn btn-warning';
            }
            
            togglePause() {
                if (this.isGameOver) return;
                
                this.isPaused = !this.isPaused;
                
                if (this.isPaused) {
                    this.pauseBtn.innerHTML = '<i class="fas fa-play"></i> RESUME';
                    this.pauseBtn.className = 'btn btn-success';
                } else {
                    this.pauseBtn.innerHTML = '<i class="fas fa-pause"></i> PAUSE';
                    this.pauseBtn.className = 'btn btn-warning';
                }
                
                this.drawBoard();
            }
            
            resetGame() {
                clearInterval(this.gameInterval);
                
                this.board = Array(20).fill().map(() => Array(10).fill(0));
                this.currentPiece = null;
                this.nextPiece = null;
                this.holdPiece = null;
                this.holdUsed = false;
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.isPaused = false;
                this.isGameOver = false;
                this.dropSpeed = 1000;
                
                this.updateDisplay();
                this.levelFillElement.style.width = '10%';
                this.pauseBtn.innerHTML = '<i class="fas fa-pause"></i> PAUSE';
                this.pauseBtn.className = 'btn btn-warning';
                
                this.createBoard();
                this.createPreviewDisplays();
            }
            
            restartGame() {
                this.gameOverModal.classList.remove('active');
                this.resetGame();
                this.startGame();
            }
            
            gameOver() {
                this.isGameOver = true;
                clearInterval(this.gameInterval);
                
                // Show game over modal
                this.finalScoreElement.textContent = this.score;
                this.finalLevelElement.textContent = this.level;
                this.finalLinesElement.textContent = this.lines;
                this.gameOverModal.classList.add('active');
            }
            
            handleKeyPress(e) {
                if (this.isGameOver && e.key !== ' ') return;
                
                switch (e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        this.movePiece(0, -1);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        this.movePiece(0, 1);
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        this.movePiece(1, 0);
                        this.score += 1;
                        this.updateDisplay();
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        this.rotatePiece();
                        break;
                    case ' ':
                        e.preventDefault();
                        if (this.isGameOver) {
                            this.restartGame();
                        } else {
                            this.hardDrop();
                        }
                        break;
                    case 'c':
                    case 'C':
                        e.preventDefault();
                        this.holdCurrentPiece();
                        break;
                    case 'p':
                    case 'P':
                        e.preventDefault();
                        this.togglePause();
                        break;
                }
            }
        }

        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new TetrisGame();
        });
    </script>
</body>
</html>